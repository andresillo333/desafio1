#include <LiquidCrystal.h>

int square(int peak);
int wave[4] = {};

int slope, y1, y;	// Valores de la pendiente y coordenadas en y
unsigned long time_s, time_f;	// Contienen el tiempo inicial y final
bool pass = false;	// Permite identificar la continuidad o no del análisis de los datos
short start=0, finish=0;	// Controlan el inicio y finalización de análisis de los datos

LiquidCrystal lcd_1(12, 11, 5, 4, 3, 2);

void setup(){
  pinMode(A0, INPUT);	// Recepción continua de datos
  pinMode(7, INPUT);	// Botón de inicio
  pinMode(6, INPUT);	// Botón de fin
  Serial.begin(9600);
  lcd_1.begin(16, 2);
}

void loop(){  

  start = digitalRead(7);
  y1 = analogRead(A0);	// Recibimos un dato del generador
  y = y1 + 0.01;	// Sumamos esto para obtener un valor muy cercano a y1
  slope = y - y1;	// Calculamos m solo con y - y1, ya que x - x1 > 0, pues se refiere al tiempo 

  if(start == 1){	// Si se presiona el botón de inicio
    Serial.println("Se presiono el boton de inicio");
    time_s = millis();	// Obtenemos el tiempo de inicio
    pass = true;	// Permitimos el análisis de datos
  }
  
  while((pass == true) && (finish != 1)){	// Si podemos analizar los datos y no hemos presionado el botón de fin  
  
    finish = digitalRead(6);
    if(finish == 1){		// Si se presiona el botón de finalización
      time_f = millis();	// Obtenemos el tiempo de finalización
      pass = false;	// Negamos el análisis de datos
      break;
  	}
    
   	y1 = analogRead(A0);
    int max = 0;
    while(y1 > max){	// Encontrando el pico de la onda
      max = y1;
      y1 = analogRead(A0);
      if(y1 == max){	// Posible onda cuadrada encontrada
        Serial.println("Posible onda cuadrada encontrada");
        *wave = square(max);
      }
    }
       
  }
  
}


int square(int peak){	// Definición de la función square
  
  Serial.print("Logramos entrar   |   ");
  Serial.println("Valor del pico: ");
  Serial.println(peak);
  
  int wave_data[4] = {};  // {t_elapsed, type, amplitude, frequency}
  unsigned long t_start, t_finish, frequency;
  int y_value, valley, amplitude, t_elapsed, ciclos = 0;
  bool found = false, update = false;	// Para verificar el encuentro del valle
  
  y_value = analogRead(A0);
  
  while(found != true){	// Mientras no se ha encontrado el valor del valle
    
    valley = y_value - 1;
    Serial.print("Valor del valle: ");
    Serial.println(valley);
    
    y_value = analogRead(A0);
    Serial.print("Valor de y: ");
    Serial.println(y_value);
    
    if((y_value > peak) && (update == false)){
      peak = y_value;
      Serial.print("Valor del pico actualizado: "); Serial.println(peak);
      update = true;
    }
    
    Serial.println("Buscando valor del valle...");
    if(y_value < valley){	// Si se encuentra el valor del valle
      valley = y_value;
      found = true;
      Serial.print("Hallamos valor del valle: "); Serial.println(valley);
      break;
    }
  }
  
  amplitude = (peak - valley)/2;
  wave_data[2] = amplitude;
  
  bool step1 = false, step2 = false;
  t_start = millis();
  
  while((y_value == peak) || (y_value == valley)){
    y_value = analogRead(A0);
    
    if(y_value == valley){  // Estamos en un valle
      step1 = true;
      Serial.println("Estamos en un valle-------------------------------------------");
    }
    if((step1 == true) && (y_value == peak)){  // Estamos en un pico
      Serial.println("Estamos en un pico");
      step2 = true;
    }
    if((step2 == true) && (y_value == valley)){  // Estamos en un valle de nuevo
      Serial.println("Estamos en un valle de nuevo");
      step1 = false; step2 = false;
      ciclos+=1;
    }
    Serial.print("Valor de 'y' antes de finalizar: "); Serial.println(y_value);
    if((y_value != peak) || (y_value != valley)){
      Serial.print("Cantidad de ciclos: "); Serial.println(ciclos);
      t_finish = millis();
      t_elapsed = t_finish - t_start;
      frequency = ciclos/(t_elapsed/1000);
      Serial.println("Ya no tenemos una onda cuadrada");
      
      wave_data[0] = t_elapsed; wave_data[3] = frequency;
      
      Serial.println("------------Data info-----------");
      Serial.print("Amplitud: "); Serial.println(amplitude);
      Serial.print("Frecuencia: "); Serial.println(frequency);
      Serial.print("Tiempo transcurrido: "); Serial.println(t_elapsed);
      
      break;
    }
  }
  
  wave_data[1] = 1;
  return *wave_data;
  
}