#include <LiquidCrystal.h>

float square(float peak);
float wave[4] = {};
float* datos_ondas;

float slope, y1, y;	// Valores de la pendiente y coordenadas en y
unsigned long time_s, time_f;	// Contienen el tiempo inicial y final
bool pass = false;	// Permite identificar la continuidad o no del análisis de los datos
short start=0, finish=0;	// Controlan el inicio y finalización de análisis de los datos
bool inicializacion=false;
LiquidCrystal lcd_1(12, 11, 5, 4, 3, 2);

void setup(){
  pinMode(A0, INPUT);	// Recepción continua de datos
  pinMode(7, INPUT);	// Botón de inicio
  pinMode(6, INPUT);	// Botón de fin
  Serial.begin(9600);
  lcd_1.begin(16, 2);
  sense(datos_ondas); 
  
}

void loop(){  

  start = digitalRead(7);
  y1 = analogRead(A0);	// Recibimos un dato del generador
  y = y1 + 0.01;	// Sumamos esto para obtener un valor muy cercano a y1
  slope = y - y1;	// Calculamos m solo con y - y1, ya que x - x1 > 0, pues se refiere al tiempo 

  if(start == 1){	// Si se presiona el botón de inicio
    Serial.println("Se presiono el boton de inicio");
    time_s = millis();	// Obtenemos el tiempo de inicio
    pass = true;	// Permitimos el análisis de datos
  }
  
  while((pass == true) && (finish != 1)){	// Si podemos analizar los datos y no hemos presionado el botón de fin  
  
    finish = digitalRead(6);
    if(finish == 1){		// Si se presiona el botón de finalización
      time_f = millis();	// Obtenemos el tiempo de finalización
      pass = false;	// Negamos el análisis de datos
      break;
  	}
    
   	y1 = analogRead(A0);
    float max = 0;
    while(y1 > max){	// Encontrando el pico de la onda
      max = y1;
      y1 = analogRead(A0);
      if(y1 == max){	// Posible onda cuadrada encontrada
        Serial.println("Posible onda cuadrada encontrada");
        *wave = square(max);
        
        if (inicializacion==false){
          datos_ondas=Datos_ondas(wave);
          inicializacion=true;
        
        }else{
          cambiar_datos(wave,datos_ondas);
          
        }
        //verificamos si el boton de finalizar ya se apreto
        //entoces llamamos a la funcions de mostrar pantalla
        //que imprimira el arreglo con mayor tiempo en el intervalo
        //en este condicional tambien se liberara despues de mostrar 
        //la informacion la memoria de la matriz dinamica
        
        
      }
    }
       
  }
  
}


float square(float peak){	// Definición de la función square
  
  Serial.print("Logramos entrar   |   ");
  Serial.println("Valor del pico: ");
  Serial.println(peak);
  
  float wave_data[4] = {};  // {t_elapsed, type, amplitude, frequency}
  unsigned long t_start, t_finish, t_elapsed;
  float y_value, valley, amplitude, frequency;
  bool found = false, update = false;	// Para verificar el encuentro del valle
  float ciclos = 0;
  
  y_value = analogRead(A0);
  //Serial.println(y_value);
  
  while(found != true){	// Mientras no se ha encontrado el valor del valle
    
    valley = y_value - 0.01;
    Serial.print("Valor del valle: ");
    Serial.println(valley);
    
    y_value = analogRead(A0);
    Serial.print("Valor de y: ");
    Serial.println(y_value);
    
    Serial.println("Buscando valor del valle...");
    if(y_value < valley){	// Si se encuentra el valor del valle
      valley = y_value;
      found = true;
      Serial.print("Hallamos valor del valle: ");
      Serial.println(valley);
      break;
    }
  }
  
  amplitude = peak - valley;
  wave_data[2] = amplitude;
  
  bool step1 = false, step2 = false;
  t_start = millis();
  
  while((y_value == peak) || (y_value == valley)){
    y_value = analogRead(A0);
    
    if(y_value == valley){  // Estamos en un valle
      step1 = true;
      Serial.println("Estamos en un valle");
    }
    if((step1 == true) && (y_value == peak)){  // Estamos en un pico
      Serial.println("Estamos en un pico");
      step2 = true;
    }
    if((step2 == true) && (y_value == valley)){  // Estamos en un valle de nuevo
      Serial.println("Estamos en un valle de nuevo");
      step1 = false; step2 = false;
      ciclos++;
    }
    if((y_value != peak) || (y_value != valley)){
      t_finish = millis();
      t_elapsed = t_finish - t_start;
      frequency = ciclos/(t_elapsed/1000);
      Serial.println("Ya no tenemos una onda cuadrada");
      
      wave_data[0] = t_elapsed; wave_data[3] = frequency;
      
      Serial.println("------------Data info-----------");
      Serial.print("Amplitud: "); Serial.println(amplitude);
      Serial.print("Frecuencia: "); Serial.println(frequency);
      Serial.print("Tiempo transcurrido: "); Serial.println(t_elapsed);
      
      break;
    }
  }
  
  wave_data[1] = 1;
  return *wave_data;
  
}



float* Datos_ondas(float *wave) {
    // Reservar el espacio para 4 floats (una fila)
    float* matriz_datos = new float[4];

    // Usar aritmética de punteros para llenar la matriz con los datos
    float* ptr = matriz_datos; // Apuntar al primer elemento del array

    *ptr     = *wave;   // Equivalente a matriz_datos[0] = amplitud;
    *(ptr + 1) =*(wave+1); // Equivalente a matriz_datos[1] = frecuencia;
    *(ptr + 2) = *(wave+2);       // Equivalente a matriz_datos[2] = tipo;
    *(ptr + 3) = *(wave+3);     // Equivalente a matriz_datos[3] = tiempo;

    return matriz_datos;
}

void cambiar_datos(float *wave, float* matriz_datos) {
    // Apuntar al primer elemento del array
    float* ptr = matriz_datos;

    // Comprobar si el nuevo tiempo es mayor que el actual
    if (*wave > *ptr) {  // Equivalente a matriz_datos[3]
        // Actualizar los datos de la matriz usando aritmética de punteros
        *ptr     = *wave;   // Equivalente a matriz_datos[0]
        *(ptr + 1) = *(wave+1); // Equivalente a matriz_datos[1]
        *(ptr + 2) = *(wave+2);       // Equivalente a matriz_datos[2]
      *(ptr + 3) = *(wave+3);     // Equivalente a matriz_datos[3]
    }
      
}
void sense(float* matriz_datos) {
    float* ptr = matriz_datos;  // Se asigna el puntero matriz_datos a ptr

    lcd_1.setCursor(0, 0);
    lcd_1.print(*(ptr+3));  // Imprime el valor en la cuarta posición del arreglo

    lcd_1.setCursor(8, 0);
    lcd_1.print("F: ");
    lcd_1.print(*(ptr+1));  // Imprime el valor de la frecuencia (segunda posición)

    lcd_1.setCursor(0, 1);
    lcd_1.print("A: ");
    lcd_1.print(*(ptr+2));  // Imprime el valor de la amplitud (tercera posición)
}